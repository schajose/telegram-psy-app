<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>PsyHold</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; touch-action:none; }
    #c { width:100vw; height:100vh; display:block; }

    :root{ --glass: rgba(255,255,255,.12); --glass2: rgba(255,255,255,.10); --stroke: rgba(255,255,255,.18); }

    .hud{
      position:fixed; left:12px; top:12px; right:12px;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      pointer-events:none;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      color:#fff;
      z-index:5;
    }
    .pill{
      background:var(--glass);
      border:1px solid rgba(255,255,255,.20);
      padding:8px 12px; border-radius:999px;
      backdrop-filter: blur(10px);
      font-size:14px; opacity:.95;
      pointer-events:none;
      white-space:nowrap;
    }
    #dangerPill{ display:none; animation:pulse .7s infinite; }
    @keyframes pulse{ 0%,100%{ transform:scale(1); opacity:.9; } 50%{ transform:scale(1.04); opacity:1; } }

    #hint{
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      background:radial-gradient(ellipse at center, rgba(0,0,0,.10), rgba(0,0,0,.86));
      backdrop-filter: blur(7px);
      color:#fff;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      z-index:6;
      pointer-events:none;
    }
    #hint .card{
      width:min(660px, calc(100vw - 28px));
      background:var(--glass2);
      border:1px solid var(--stroke);
      border-radius:26px;
      padding:18px 16px;
      box-shadow:0 24px 80px rgba(0,0,0,.55);
      text-align:center;
    }
    #hint .title{ font-size:28px; font-weight:950; letter-spacing:.2px; }
    #hint .sub{ margin-top:10px; opacity:.93; line-height:1.38; font-size:15px; }
    #hint .sub b{ opacity:1; }
    #hint .tiny{ margin-top:10px; opacity:.78; font-size:13px; line-height:1.35; }

    #result{
      position:fixed; inset:0; display:none; align-items:center; justify-content:center;
      background:rgba(0,0,0,.64);
      backdrop-filter: blur(10px);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      color:#fff;
      z-index:10;
    }
    #result .card{
      width:min(740px, calc(100vw - 28px));
      background:var(--glass2);
      border:1px solid var(--stroke);
      border-radius:28px;
      padding:18px;
      box-shadow:0 28px 100px rgba(0,0,0,.62);
      text-align:center;
    }
    #creature{ font-size:78px; line-height:1.05; filter: drop-shadow(0 16px 30px rgba(0,0,0,.40)); }
    #headline{ margin-top:8px; font-size:22px; font-weight:950; letter-spacing:.2px; }
    #subtitle{ margin-top:6px; font-size:15px; opacity:.92; line-height:1.35; }
    #meta{
      margin-top:10px; font-size:13px; opacity:.82;
      display:flex; justify-content:center; gap:10px; flex-wrap:wrap;
    }
    .tag{
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.08);
      padding:6px 10px; border-radius:999px;
    }

    .btnrow{ display:flex; gap:10px; margin-top:14px; }
    button{
      flex:1; border:0; border-radius:16px; padding:12px 14px;
      color:#fff; font-weight:900; letter-spacing:.2px;
      background:rgba(255,255,255,.14); backdrop-filter: blur(10px);
    }
    button:active{ transform: translateY(1px); }
    .secondary{ background:rgba(255,255,255,.10); font-weight:800; opacity:.96; }

    #toast{
      position:fixed; left:12px; right:12px; bottom:12px;
      display:none; z-index:30; justify-content:center;
      pointer-events:none;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      color:#fff;
    }
    #toast .pill{
      pointer-events:none;
      background:rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.18);
      padding:10px 14px; border-radius:999px;
      backdrop-filter: blur(10px);
      font-size:14px;
      box-shadow:0 20px 60px rgba(0,0,0,.55);
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="pill" id="statusPill">Hold to reveal ‚ú®</div>
    <div class="pill" id="dangerPill">DANGER</div>
  </div>

  <div id="hint">
    <div class="card">
      <div class="title">PsyHold</div>
      <div class="sub">
        Press & hold anywhere.<br/>
        <b>No timer.</b> Pure instinct.<br/>
        Reveal the hidden creature ‚Äî then release close to <b>10.00s</b>.<br/>
        Hold too long‚Ä¶ you die.
      </div>
      <div class="tiny">
        Pro tip: stay <b>steady</b>. Finger motion fuels the chaos.
      </div>
    </div>
  </div>

  <div id="result">
    <div class="card">
      <div id="creature">ü¶Ñ</div>
      <div id="headline">NICE NERVES.</div>
      <div id="subtitle">Score: 9.63s ‚Ä¢ Mythic Unicorn (Ascended)</div>
      <div id="meta"></div>
      <div class="btnrow">
        <button id="shareBtn">Share</button>
        <button id="againBtn" class="secondary">Play again</button>
      </div>
    </div>
  </div>

  <div id="toast"><div class="pill" id="toastText">Copied.</div></div>

<script>
(() => {
  // =======================
  // Telegram helpers
  // =======================
  const tg = (window.Telegram && window.Telegram.WebApp) ? window.Telegram.WebApp : null;
  if (tg) { try { tg.ready(); tg.expand(); } catch(e){} }

  function hapticImpact(level) {
    if (!tg?.HapticFeedback) return;
    try { tg.HapticFeedback.impactOccurred(level); } catch(e){}
  }
  function hapticNotif(type) {
    if (!tg?.HapticFeedback) return;
    try { tg.HapticFeedback.notificationOccurred(type); } catch(e){}
  }

  const toast = document.getElementById("toast");
  const toastText = document.getElementById("toastText");
  let toastT = null;
  function showToast(msg){
    toastText.textContent = msg;
    toast.style.display = "flex";
    clearTimeout(toastT);
    toastT = setTimeout(()=> toast.style.display = "none", 1200);
  }

  function shareText(text) {
    const shareUrl =
      "https://t.me/share/url" +
      "?url=" + encodeURIComponent(location.href) +
      "&text=" + encodeURIComponent(text);

    if (tg && typeof tg.openTelegramLink === "function") {
      tg.openTelegramLink(shareUrl);
      return;
    }
    try { window.open(shareUrl, "_blank", "noopener,noreferrer"); return; } catch(_) {}
    if (navigator.clipboard?.writeText) {
      navigator.clipboard.writeText(text).then(()=>showToast("Copied to clipboard")).catch(()=>{});
      return;
    }
    prompt("Copy this:", text);
  }

  // =======================
  // DOM
  // =======================
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });

  const hint = document.getElementById('hint');
  const result = document.getElementById('result');

  const statusPill = document.getElementById('statusPill');
  const dangerPill = document.getElementById('dangerPill');

  const creatureEl = document.getElementById('creature');
  const headlineEl = document.getElementById('headline');
  const subtitleEl = document.getElementById('subtitle');
  const metaEl = document.getElementById('meta');

  const shareBtn = document.getElementById('shareBtn');
  const againBtn = document.getElementById('againBtn');

  // =======================
  // Canvas sizing
  // =======================
  let W=0,H=0,dpr=1;
  function resize(){
    dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = Math.floor(innerWidth * dpr);
    H = Math.floor(innerHeight * dpr);
    canvas.width = W; canvas.height = H;
    canvas.style.width = innerWidth + "px";
    canvas.style.height = innerHeight + "px";
  }
  addEventListener('resize', resize);
  resize();

  // =======================
  // Core knobs
  // =======================
  const MAX_MS = 10_000;
  const CREATURE_START_MS = 8_500;
  const DANGER_MS = 7_000;

  const CLOSE_MS  = 9_300;
  const LEGEND_MS = 9_700;

  const REVEAL_START_MS = 200;     // reveal begins almost immediately
  const REVEAL_CLEAR_MS = 6_800;   // by ~6.8s the hidden glyph is mostly visible
  const GHOST_MS = 9_050;          // late tease flicker
  const FLASH_MS = 9_900;

  const HAPTIC_STAGES = [7000, 8000, 8700, 9200, 9600, 9850];

  // Movement -> chaos coupling (steady hand)
  const MOVE_FALLOFF = 0.90;
  const MOVE_GAIN = 1.75;

  const toHundredths = (ms) => (Math.floor((ms/1000) * 100) / 100).toFixed(2);

  // =======================
  // Local PB + streak (micro dopamine)
  // =======================
  const LS_STREAK = "psyhold_streak_v3";
  const LS_LASTDAY = "psyhold_lastday_v3";
  const LS_PB = "psyhold_pb_v3";

  function dayKey(d=new Date()){
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,'0');
    const da = String(d.getDate()).padStart(2,'0');
    return `${y}-${m}-${da}`;
  }

  function bumpStreakIfFirstShareToday(){
    const s = parseInt(localStorage.getItem(LS_STREAK) || "0", 10);
    const last = localStorage.getItem(LS_LASTDAY) || "";
    const today = dayKey();
    if (last === today) return s;

    const lastDate = last ? new Date(last + "T00:00:00") : null;
    const todayDate = new Date(today + "T00:00:00");
    const diffDays = lastDate ? Math.round((todayDate - lastDate) / (24*3600*1000)) : 999;

    let newStreak = 1;
    if (diffDays === 1) newStreak = Math.max(1, s + 1);

    localStorage.setItem(LS_STREAK, String(newStreak));
    localStorage.setItem(LS_LASTDAY, today);
    return newStreak;
  }

  function updatePB(msHeld){
    const pb = parseFloat(localStorage.getItem(LS_PB) || "0") || 0;
    const score = parseFloat(toHundredths(msHeld));
    if (!pb || score > pb) {
      localStorage.setItem(LS_PB, String(score));
      return score;
    }
    return pb;
  }

  // =======================
  // Creatures (emoji)
  // =======================
  const CREATURES = [
    { emoji:"ü¶Ñ", name:"Unicorn", rarity:"Mythic" },
    { emoji:"üêâ", name:"Dragon", rarity:"Mythic" },
    { emoji:"üßö", name:"Fairy", rarity:"Epic" },
    { emoji:"üëÅÔ∏è", name:"Cosmic Eye", rarity:"Epic" },
    { emoji:"ü¶ã", name:"Lumen Moth", rarity:"Epic" },
    { emoji:"üêç", name:"Ouroboros", rarity:"Rare" },
    { emoji:"ü¶Å", name:"Chimera", rarity:"Rare" },
    { emoji:"üê∫", name:"Moon Wolf", rarity:"Rare" },
    { emoji:"ü¶ä", name:"Fox Spirit", rarity:"Uncommon" },
    { emoji:"üêô", name:"Void Octo", rarity:"Uncommon" },
    { emoji:"ü™º", name:"Jelly Wisp", rarity:"Uncommon" },
    { emoji:"üê∏", name:"Trick Toad", rarity:"Common" }
  ];

  function evolutionFor(msHeld){
    if (msHeld >= LEGEND_MS) return { label:"Ascended" };
    if (msHeld >= CLOSE_MS)  return { label:"Evolved" };
    return { label:"Awakened" };
  }

  function microTitle(msHeld, died=false){
    if (died) return "TOO FAR.";
    if (msHeld >= 9900) return "TIME BENDER.";
    if (msHeld >= 9700) return "ABSURD CONTROL.";
    if (msHeld >= 9500) return "NERVE OF STEEL.";
    if (msHeld >= 9300) return "EDGE WALKER.";
    if (msHeld >= 9000) return "STEADY HANDS.";
    if (msHeld >= CREATURE_START_MS) return "NICE NERVES.";
    return "ALMOST‚Ä¶";
  }

  function pickCreature(msHeld){
    const p = Math.max(0, Math.min(1, msHeld / MAX_MS));
    const expo = Math.pow(p, 3.1);

    if (msHeld >= LEGEND_MS && Math.random() < 0.62) {
      const mythics = CREATURES.filter(c => c.rarity === "Mythic");
      return mythics[(Math.random()*mythics.length)|0];
    }
    if (msHeld >= CLOSE_MS && Math.random() < 0.48) {
      const hi = CREATURES.filter(c => c.rarity === "Epic" || c.rarity === "Mythic");
      return hi[(Math.random()*hi.length)|0];
    }

    const buckets = [
      { filter: c => c.rarity === "Common",   w: 1.00 - expo*0.95 },
      { filter: c => c.rarity === "Uncommon", w: 0.55 + expo*0.38 },
      { filter: c => c.rarity === "Rare",     w: 0.15 + expo*0.52 },
      { filter: c => c.rarity === "Epic",     w: 0.05 + expo*0.58 },
      { filter: c => c.rarity === "Mythic",   w: 0.01 + expo*0.45 }
    ];
    const total = buckets.reduce((s,b)=> s + Math.max(0,b.w), 0);
    let r = Math.random() * total;
    let chosen = buckets[0];
    for (const b of buckets) { r -= Math.max(0,b.w); if (r <= 0) { chosen = b; break; } }
    const pool = CREATURES.filter(chosen.filter);
    return pool[(Math.random()*pool.length)|0];
  }

  // =======================
  // Visual engine
  // =======================
  const rand = (a,b)=>a+Math.random()*(b-a);
  let seedA = rand(0, 1000), seedB = rand(0, 1000), seedC = rand(0, 1000);
  function newSeeds(){ seedA=rand(0,1000); seedB=rand(0,1000); seedC=rand(0,1000); }
  function clearCanvas(){ ctx.fillStyle="#000"; ctx.fillRect(0,0,W,H); }

  // Movement tracking
  let ptrDown = false;
  let ptrX = 0, ptrY = 0, lastMoveT = 0;
  let moveEnergy = 0;     // smoothed
  let moveEnergyPeak = 0; // peak (decays slowly)

  function updateMoveEnergy(x, y, now){
    if (!lastMoveT) { lastMoveT = now; ptrX = x; ptrY = y; return; }
    const dt = Math.max(1, now - lastMoveT);
    const dx = x - ptrX;
    const dy = y - ptrY;
    ptrX = x; ptrY = y; lastMoveT = now;

    const v = Math.sqrt(dx*dx + dy*dy) / dt; // px/ms
    const sample = Math.min(2.5, v * 28);
    moveEnergy = moveEnergy * MOVE_FALLOFF + sample * (1 - MOVE_FALLOFF);
    moveEnergyPeak = Math.max(moveEnergyPeak * 0.995, moveEnergy);
  }

  // Drift: subtle slipping world (feels alive)
  let driftX = 0, driftY = 0, driftVX = 0, driftVY = 0;

  // Hidden glyph for early engagement (pixel reveal)
  const HIDDEN_SET = ["ü¶Ñ","üêâ","üßö","üëÅÔ∏è","ü¶ã","üêç","ü¶Å","üê∫","ü¶ä","üêô","ü™º"];
  let hiddenGlyph = HIDDEN_SET[(Math.random()*HIDDEN_SET.length)|0];

  function lerp(a,b,t){ return a + (b-a)*t; }
  function clamp01(x){ return Math.max(0, Math.min(1, x)); }

  function drawCore(msHeld, chaos, dx, dy){
    const p = clamp01(msHeld / MAX_MS);
    const expo = Math.pow(p, 2.5);

    const cx = W/2 + dx;
    const cy = H/2 + dy;

    const baseR = Math.min(W,H) * 0.055;
    const r = baseR * (1.0 + expo*2.25) * (1.0 + chaos*0.18);
    const pulse = 0.5 + 0.5*Math.sin(msHeld/1000 * (2.2 + expo*6.5));
    const alpha = 0.07 + expo*0.16;

    const g = ctx.createRadialGradient(cx, cy, r*0.2, cx, cy, r*1.3);
    g.addColorStop(0, `rgba(255,255,255,${alpha + pulse*0.06})`);
    g.addColorStop(0.35, `rgba(120,255,240,${alpha*0.55})`);
    g.addColorStop(0.7, `rgba(255,0,120,${alpha*0.22})`);
    g.addColorStop(1, `rgba(0,0,0,0)`);
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(cx, cy, r*1.3, 0, Math.PI*2); ctx.fill();

    const g2 = ctx.createRadialGradient(cx, cy, 0, cx, cy, r*0.45);
    g2.addColorStop(0, `rgba(255,255,255,${0.12 + pulse*0.12})`);
    g2.addColorStop(1, `rgba(0,0,0,0)`);
    ctx.fillStyle = g2;
    ctx.beginPath(); ctx.arc(cx, cy, r*0.45, 0, Math.PI*2); ctx.fill();

    // ring progress (no timer, but a *feeling* of progress)
    const rings = 3;
    const ringP = clamp01((msHeld - 400) / 8600); // 0..1
    ctx.lineWidth = Math.max(1, 2*dpr);
    for (let i=0; i<rings; i++){
      const rr = r*(0.95 + i*0.36);
      const a = 0.05 + expo*0.08;
      ctx.strokeStyle = `rgba(255,255,255,${a * (1 - i*0.16)})`;
      ctx.beginPath();
      ctx.arc(cx, cy, rr, -Math.PI/2, -Math.PI/2 + (Math.PI*2) * Math.max(0, ringP - i*0.25));
      ctx.stroke();
    }
  }

  function renderPsy(msHeld, chaos, dx, dy){
    const p = clamp01(msHeld / MAX_MS);
    const expo = Math.pow(p, 2.75);

    // time deformation
    const timeWarp = 1.0 - Math.max(0, (p - 0.82)) * 0.55;
    const t = (msHeld/1000) * timeWarp;

    const sp = 0.35 + expo * 3.25;
    const zoom = 0.92 + expo * 2.25;

    const wob = (p > 0.78 ? (p - 0.78) : 0) * (0.12 + chaos*0.10);
    const wobX = Math.sin(t*18) * wob * W;
    const wobY = Math.cos(t*17) * wob * H;

    const cx = W/2 + dx + wobX;
    const cy = H/2 + dy + wobY;

    const block = Math.max(2, Math.floor((7 - expo*4.9) * dpr));

    const bite = (p > 0.88) ? (p - 0.88) * 1.8 : 0;

    for (let y=0; y<H; y+=block){
      for (let x=0; x<W; x+=block){
        const nx = ((x - cx)/W) * 2 * zoom;
        const ny = ((y - cy)/H) * 2 * zoom;

        const v =
          Math.sin(nx*3 + seedA + t*sp) +
          Math.cos(ny*4 + seedB - t*sp*0.92) +
          Math.sin((nx+ny)*2 + seedC + t*sp*1.18);

        const r = 128 + 127*Math.sin(v + t*1.28 + bite*1.1);
        const g = 128 + 127*Math.sin(v + 2.094 + t*1.06 - bite*0.8);
        const b = 128 + 127*Math.sin(v + 4.188 + t*0.86 + bite*0.4);

        ctx.fillStyle = `rgb(${r|0},${g|0},${b|0})`;
        ctx.fillRect(x, y, block, block);
      }
    }

    const vg = ctx.createRadialGradient(W/2,H/2, Math.min(W,H)*0.10, W/2,H/2, Math.min(W,H)*0.82);
    vg.addColorStop(0, "rgba(0,0,0,0)");
    vg.addColorStop(1, `rgba(0,0,0,${0.24 + expo*0.50})`);
    ctx.fillStyle = vg;
    ctx.fillRect(0,0,W,H);

    if (p > 0.70) {
      ctx.fillStyle = `rgba(255, 0, 70, ${(p-0.70)*(0.22 + chaos*0.10)})`;
      ctx.fillRect(0,0,W,H);
    }

    // subtle "glitch shear" near death
    if (p > 0.90) {
      const k = (p - 0.90) * (0.22 + chaos*0.12);
      ctx.globalAlpha = Math.min(0.10, k);
      const sx = Math.floor(Math.sin(t*23) * 10 * dpr);
      ctx.drawImage(canvas, sx, 0);
      ctx.globalAlpha = 1;
    }
  }

  // Pixel-reveal hidden glyph (early hook)
  function drawReveal(msHeld, dx, dy, chaos){
    if (msHeld < REVEAL_START_MS) return;

    const p = clamp01((msHeld - REVEAL_START_MS) / (REVEAL_CLEAR_MS - REVEAL_START_MS));
    const pEase = Math.pow(p, 0.85); // faster early reveal so it's interesting immediately

    // pixel size shrinks over time (starts very chunky)
    const pxBig = Math.max(18, Math.floor((50 - pEase*46) * dpr)); // ~50 -> ~4
    const px = Math.max(3, pxBig);

    // position & wobble
    const cx = W/2 + dx;
    const cy = H/2 + dy;
    const t = msHeld/1000;
    const bob = Math.sin(t*3.4) * Math.min(W,H) * 0.012;

    // draw hidden glyph to offscreen at low resolution, then upscale (pixelated)
    // Create tiny temp canvas on demand (cached)
    if (!drawReveal.tmp) {
      drawReveal.tmp = document.createElement("canvas");
      drawReveal.tctx = drawReveal.tmp.getContext("2d");
    }
    const tmp = drawReveal.tmp;
    const tctx = drawReveal.tctx;

    const smallW = Math.max(24, Math.floor(W / px));
    const smallH = Math.max(24, Math.floor(H / px));
    if (tmp.width !== smallW || tmp.height !== smallH) { tmp.width = smallW; tmp.height = smallH; }

    // Clear small
    tctx.clearRect(0,0,smallW,smallH);

    // Determine glyph size on small canvas
    const gx = (smallW/2);
    const gy = (smallH/2) + (bob/px);

    // Glow intensity grows with reveal
    const glow = 0.04 + pEase*0.16 + chaos*0.04;

    // draw glow behind glyph (on small canvas)
    tctx.save();
    tctx.globalAlpha = glow;
    tctx.fillStyle = "#ffffff";
    tctx.textAlign = "center";
    tctx.textBaseline = "middle";
    tctx.font = `${Math.floor(Math.min(smallW, smallH) * (0.55 + pEase*0.10))}px system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
    tctx.fillText(hiddenGlyph, gx, gy);
    tctx.restore();

    // upscale to main canvas with pixelation
    ctx.save();
    ctx.imageSmoothingEnabled = false;
    ctx.globalAlpha = 0.22 + pEase*0.40; // faint at first, clearer later
    ctx.drawImage(tmp, 0, 0, smallW, smallH, 0, 0, W, H);
    ctx.restore();

    // hint textless cue: small sparkles when reveal passes certain thresholds
    if (pEase > 0.22 && pEase < 0.26) microSpark(cx, cy, 0.35);
    if (pEase > 0.55 && pEase < 0.59) microSpark(cx, cy, 0.55);
  }

  function microSpark(cx, cy, strength){
    // tiny spark burst - short-lived (called only at thresholds)
    ctx.save();
    ctx.globalAlpha = 0.10 + strength*0.12;
    for (let i=0;i<16;i++){
      const a = (i/16) * Math.PI*2 + rand(-0.08,0.08);
      const r = (Math.min(W,H) * (0.04 + strength*0.03)) * rand(0.5, 1.0);
      const x = cx + Math.cos(a)*r;
      const y = cy + Math.sin(a)*r;
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.fillRect(x, y, 2*dpr, 2*dpr);
    }
    ctx.restore();
  }

  // Late tease flicker (near-reward)
  function drawGhostCreature(msHeld, dx, dy){
    if (msHeld < GHOST_MS) return;

    const p = clamp01(msHeld / MAX_MS);
    const expo = Math.pow(p, 3.0);
    const t = msHeld / 1000;

    const flicker = Math.max(0, Math.sin(t * (9 + expo*18)));
    const show = (msHeld > 9300) ? (flicker > 0.15) : (flicker > 0.45);
    if (!show) return;

    const ghosts = ["ü¶Ñ","üêâ","üßö","üëÅÔ∏è","ü¶ã"];
    const glyph = ghosts[(Math.random()*ghosts.length)|0];

    ctx.save();
    ctx.globalAlpha = 0.05 + expo*0.16;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = `${Math.floor((Math.min(W,H) / dpr) * (0.18 + expo*0.08))}px system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
    ctx.fillText(glyph, (W/2 + dx)/dpr, (H/2 + dy)/dpr);
    ctx.restore();
  }

  function nearDeathFlash(){
    ctx.fillStyle = "rgba(255,255,255,.085)";
    ctx.fillRect(0,0,W,H);
  }

  function deathCollapse(){
    ctx.fillStyle = "rgba(0,0,0,.38)";
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = "rgba(255,0,90,.18)";
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = "rgba(255,255,255,.04)";
    ctx.fillRect(0,0,W,H);
  }

  // =======================
  // Audio (soft heartbeat)
  // =======================
  let audioCtx = null, osc = null, gain = null, audioEnabled = false;

  function ensureAudio(){
    if (audioCtx) return;
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      osc = audioCtx.createOscillator();
      gain = audioCtx.createGain();
      osc.type = "sine";
      osc.frequency.value = 70;
      gain.gain.value = 0.0;
      osc.connect(gain).connect(audioCtx.destination);
      osc.start();
    } catch(e) { audioCtx = null; }
  }

  function setHeartbeat(msHeld){
    if (!audioEnabled || !audioCtx || !osc || !gain) return;
    const p = clamp01(msHeld / MAX_MS);
    const expo = Math.pow(p, 2.3);
    osc.frequency.setValueAtTime(70 + expo * 170, audioCtx.currentTime);
    const vol = (msHeld < DANGER_MS) ? 0.0 : Math.min(0.05, (msHeld - DANGER_MS) / 3500 * 0.05);
    gain.gain.setTargetAtTime(vol, audioCtx.currentTime, 0.03);
  }

  function muteHeartbeat(){
    if (!gain || !audioCtx) return;
    gain.gain.setTargetAtTime(0.0, audioCtx.currentTime, 0.03);
  }

  // =======================
  // State
  // =======================
  let holding = false, dead = false;
  let holdStart = 0;
  let rafId = null;
  let lastHapticStage = -1;
  let flashed = false;

  let lastResultText = "";
  let lastSafeMs = 0;

  function setUIIdle(){
    dangerPill.style.display = "none";
    statusPill.textContent = "Hold to reveal ‚ú®";
  }
  function setUIPlaying(){
    hint.style.display = "none";
    result.style.display = "none";
    dangerPill.style.display = "none";
    statusPill.textContent = "Hold‚Ä¶ stay steady";
  }

  function resetRound({ showHint=false } = {}){
    holding = false; dead = false;
    lastHapticStage = -1; flashed = false;
    lastSafeMs = 0;
    lastResultText = "";

    moveEnergy = 0; moveEnergyPeak = 0;
    driftX = 0; driftY = 0; driftVX = 0; driftVY = 0;
    lastMoveT = 0;

    newSeeds();
    clearCanvas();

    // new hidden glyph each round (early hook)
    hiddenGlyph = HIDDEN_SET[(Math.random()*HIDDEN_SET.length)|0];

    hint.style.display = showHint ? "flex" : "none";
    result.style.display = "none";
    setUIIdle();
  }

  function dangerFeedback(msHeld){
    if (msHeld < DANGER_MS) { dangerPill.style.display = "none"; return; }
    dangerPill.style.display = "inline-block";

    let stage = -1;
    for (let i=0; i<HAPTIC_STAGES.length; i++){
      if (msHeld >= HAPTIC_STAGES[i]) stage = i;
    }
    if (stage !== lastHapticStage) {
      lastHapticStage = stage;
      if (stage <= 0) hapticImpact("light");
      else if (stage === 1) hapticImpact("medium");
      else hapticImpact("heavy");
    }
  }

  function renderMeta(labels){
    metaEl.innerHTML = "";
    for (const label of labels) {
      const span = document.createElement("span");
      span.className = "tag";
      span.textContent = label;
      metaEl.appendChild(span);
    }
  }

  function challengeLine(scoreStr, died){
    if (died) return "I died. Can you get closer to 10.00s and survive?";
    const score = parseFloat(scoreStr);
    if (score >= 9.80) return "I dare you to cross 9.90 without dying.";
    if (score >= 9.60) return "Beat 9.70 without dying.";
    if (score >= 9.30) return "Beat 9.50 without dying.";
    return "Get closer to 10.00 without dying.";
  }

  function showResultCard({ died, msHeld, creature, evo }){
    const pb = (!died) ? updatePB(msHeld) : (parseFloat(localStorage.getItem(LS_PB) || "0") || 0);
    const streak = parseInt(localStorage.getItem(LS_STREAK) || "0", 10);

    const safeHund = toHundredths(Math.max(0, Math.min(MAX_MS - 1, lastSafeMs)));
    const scoreStr = toHundredths(msHeld);
    const leftHund = toHundredths(Math.max(0, MAX_MS - msHeld));

    const calm = Math.max(0, 1 - (moveEnergyPeak * MOVE_GAIN) / 3.0);
    const calmLabel = `Steadiness: ${Math.round(calm*100)}%`;

    if (died) {
      creatureEl.textContent = "üíÄ";
      headlineEl.textContent = microTitle(msHeld, true);
      subtitleEl.textContent = `You held too long. Death at 10.00s.`;
      renderMeta([`üíÄ Death`, `Safe: ${safeHund}s`, calmLabel, pb ? `PB: ${pb.toFixed(2)}s` : null, streak ? `Streak: ${streak}d` : null].filter(Boolean));
      lastResultText = `üíÄ PsyHold: I died. Last safe moment ${safeHund}s. ${challengeLine(scoreStr, true)}\nPlay: ${location.href}`;
      hapticNotif("error");
    } else if (msHeld < CREATURE_START_MS) {
      creatureEl.textContent = "‚ú®";
      headlineEl.textContent = microTitle(msHeld, false);
      subtitleEl.textContent = `You almost had it. Hold longer ‚Äî but don‚Äôt die.`;
      renderMeta([`‚ú® Survived`, `Reveal: ${hiddenGlyph}`, calmLabel, pb ? `PB: ${pb.toFixed(2)}s` : null, streak ? `Streak: ${streak}d` : null].filter(Boolean));
      // snacky share (keeps it clickable)
      lastResultText = `‚ú® PsyHold: I almost revealed ${hiddenGlyph}. ${challengeLine(scoreStr, false)}\nPlay: ${location.href}`;
      hapticNotif("warning");
    } else {
      creatureEl.textContent = creature.emoji;
      headlineEl.textContent = microTitle(msHeld, false);
      subtitleEl.textContent = `Score: ${scoreStr}s ‚Ä¢ ${creature.rarity} ${creature.name} (${evo.label})`;
      renderMeta([`‚ú® Survived`, `${creature.rarity}`, `${evo.label}`, `${leftHund}s from death`, calmLabel, pb ? `PB: ${pb.toFixed(2)}s` : null, streak ? `Streak: ${streak}d` : null].filter(Boolean));
      lastResultText = `${creature.emoji} PsyHold: ${scoreStr}s ‚Ä¢ ${creature.rarity} ${creature.name} (${evo.label}). ${challengeLine(scoreStr, false)}\nPlay: ${location.href}`;
      hapticNotif("success");
    }

    result.style.display = "flex";
  }

  function dieNow(msHeld){
    if (dead) return;
    dead = true;
    holding = false;

    statusPill.textContent = "TOO FAR";
    dangerPill.style.display = "none";

    deathCollapse();
    muteHeartbeat();

    showResultCard({ died:true, msHeld, creature:null, evo:null });
  }

  function startHold(now){
    if (result.style.display === "flex") return;

    ensureAudio();
    if (audioCtx && audioCtx.state === "suspended") { audioCtx.resume().catch(()=>{}); }
    audioEnabled = true;

    holding = true;
    dead = false;
    holdStart = now;
    lastHapticStage = -1;
    flashed = false;
    lastSafeMs = 0;
    moveEnergy = 0;
    moveEnergyPeak = 0;

    driftX = 0; driftY = 0; driftVX = 0; driftVY = 0;

    setUIPlaying();
    if (!rafId) rafId = requestAnimationFrame(loop);
  }

  function releaseHold(now){
    if (!holding) return;
    holding = false;

    const msHeld = now - holdStart;
    muteHeartbeat();

    if (msHeld >= MAX_MS) { dieNow(msHeld); return; }

    let creature = null, evo = null;
    if (msHeld >= CREATURE_START_MS) {
      creature = pickCreature(msHeld);
      evo = evolutionFor(msHeld);
    }

    showResultCard({ died:false, msHeld, creature, evo });
  }

  function loop(now){
    if (holding && !dead) {
      const msHeld = now - holdStart;
      lastSafeMs = Math.min(MAX_MS - 1, msHeld);

      const p = clamp01(msHeld / MAX_MS);
      const timeDanger = Math.max(0, p - 0.65) / 0.35; // 0..1 after ~6.5s
      const chaos = Math.min(1, (timeDanger*0.85 + moveEnergy*0.25) * MOVE_GAIN);

      // drift slips more with chaos
      const pull = 0.0009 + timeDanger*0.0030;
      driftVX += (rand(-1,1) * (0.05 + chaos*0.35)) * pull * W;
      driftVY += (rand(-1,1) * (0.05 + chaos*0.35)) * pull * H;

      const friction = 0.88 - timeDanger*0.20;
      driftVX *= friction; driftVY *= friction;

      driftX += driftVX; driftY += driftVY;
      const clampD = Math.min(W,H) * (0.12 + chaos*0.06);
      driftX = Math.max(-clampD, Math.min(clampD, driftX));
      driftY = Math.max(-clampD, Math.min(clampD, driftY));

      if (msHeld >= MAX_MS) {
        dieNow(msHeld);
      } else {
        renderPsy(msHeld, chaos, driftX, driftY);

        // early hook: pixel reveal every frame
        drawReveal(msHeld, driftX, driftY, chaos);

        // core magnet
        drawCore(msHeld, chaos, driftX, driftY);

        // late tease (near reward)
        drawGhostCreature(msHeld, driftX, driftY);

        // danger cues
        dangerFeedback(msHeld);

        // near-death flash (once)
        if (!flashed && msHeld >= FLASH_MS) {
          flashed = true;
          nearDeathFlash();
          hapticImpact("heavy");
        }

        setHeartbeat(msHeld);
      }
    }
    rafId = requestAnimationFrame(loop);
  }

  // =======================
  // Input
  // =======================
  function canvasPoint(e){
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * dpr;
    const y = (e.clientY - rect.top) * dpr;
    return { x, y };
  }

  canvas.addEventListener('pointerdown', (e)=>{
    e.preventDefault();
    ptrDown = true;
    const now = performance.now();
    const p = canvasPoint(e);
    updateMoveEnergy(p.x, p.y, now);
    try { canvas.setPointerCapture(e.pointerId); } catch(_) {}
    startHold(now);
  }, {passive:false});

  canvas.addEventListener('pointermove', (e)=>{
    if (!ptrDown) return;
    const now = performance.now();
    const p = canvasPoint(e);
    updateMoveEnergy(p.x, p.y, now);
  }, {passive:false});

  canvas.addEventListener('pointerup', (e)=>{
    e.preventDefault();
    ptrDown = false;
    releaseHold(performance.now());
  }, {passive:false});

  canvas.addEventListener('pointercancel', ()=>{
    ptrDown = false;
    releaseHold(performance.now());
  });

  // =======================
  // Buttons
  // =======================
  againBtn.addEventListener('click', ()=>{
    result.style.display = "none";
    resetRound();
  });

  shareBtn.addEventListener('click', ()=>{
    const newStreak = bumpStreakIfFirstShareToday();
    const pb = parseFloat(localStorage.getItem(LS_PB) || "0") || 0;

    let line = lastResultText;
    if (!line) line = `PsyHold: no timer. 10.00s = death. Beat me.\nPlay: ${location.href}`;

    let extra = "";
    if (newStreak) extra += ` ‚Ä¢ ${newStreak}d streak`;
    if (pb) extra += ` ‚Ä¢ PB ${pb.toFixed(2)}s`;
    shareText(line + extra);
  });

  // Tap outside result to close (instant retry loop)
  result.addEventListener("click", (e)=>{
    if (e.target === result) {
      result.style.display = "none";
      resetRound();
    }
  });

  // =======================
  // Boot
  // =======================
  resetRound({ showHint:true });
})();
</script>
</body>
</html>
