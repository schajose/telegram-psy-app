<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>PsyHold</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; touch-action:none; }
    #c { width:100vw; height:100vh; display:block; }

    :root{
      --glass: rgba(255,255,255,.12);
      --glass2: rgba(255,255,255,.10);
      --stroke: rgba(255,255,255,.18);
    }

    .hud{
      position:fixed; left:12px; top:12px; right:12px;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      pointer-events:none;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      color:#fff;
      z-index:5;
    }
    .pill{
      background:var(--glass);
      border:1px solid rgba(255,255,255,.20);
      padding:8px 12px; border-radius:999px;
      backdrop-filter: blur(10px);
      font-size:14px; opacity:.95;
      pointer-events:none;
      white-space:nowrap;
    }
    #dangerPill{
      display:none;
      animation: pulse .7s infinite;
    }
    @keyframes pulse{ 0%,100%{ transform:scale(1); opacity:.9; } 50%{ transform:scale(1.04); opacity:1; } }

    #hint{
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      background:radial-gradient(ellipse at center, rgba(0,0,0,.10), rgba(0,0,0,.84));
      backdrop-filter: blur(7px);
      color:#fff;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      z-index:6;
      pointer-events:none;
    }
    #hint .card{
      width:min(640px, calc(100vw - 28px));
      background:var(--glass2);
      border:1px solid var(--stroke);
      border-radius:26px;
      padding:18px 16px;
      box-shadow:0 24px 80px rgba(0,0,0,.55);
      text-align:center;
    }
    #hint .title{ font-size:28px; font-weight:950; letter-spacing:.2px; }
    #hint .sub{ margin-top:10px; opacity:.93; line-height:1.38; font-size:15px; }
    #hint .sub b{ opacity:1; }
    #hint .tiny{ margin-top:10px; opacity:.78; font-size:13px; line-height:1.35; }

    #result{
      position:fixed; inset:0; display:none; align-items:center; justify-content:center;
      background:rgba(0,0,0,.64);
      backdrop-filter: blur(10px);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      color:#fff;
      z-index:10;
    }
    #result .card{
      width:min(720px, calc(100vw - 28px));
      background:var(--glass2);
      border:1px solid var(--stroke);
      border-radius:28px;
      padding:18px;
      box-shadow:0 28px 100px rgba(0,0,0,.62);
      text-align:center;
    }
    #creature{ font-size:78px; line-height:1.05; filter: drop-shadow(0 16px 30px rgba(0,0,0,.40)); }
    #headline{ margin-top:8px; font-size:22px; font-weight:950; letter-spacing:.2px; }
    #subtitle{ margin-top:6px; font-size:15px; opacity:.92; line-height:1.35; }
    #meta{
      margin-top:10px; font-size:13px; opacity:.82;
      display:flex; justify-content:center; gap:10px; flex-wrap:wrap;
    }
    .tag{
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.08);
      padding:6px 10px; border-radius:999px;
    }

    .btnrow{ display:flex; gap:10px; margin-top:14px; }
    button{
      flex:1; border:0; border-radius:16px; padding:12px 14px;
      color:#fff; font-weight:900; letter-spacing:.2px;
      background:rgba(255,255,255,.14); backdrop-filter: blur(10px);
    }
    button:active{ transform: translateY(1px); }
    .secondary{ background:rgba(255,255,255,.10); font-weight:800; opacity:.96; }

    #toast{
      position:fixed; left:12px; right:12px; bottom:12px;
      display:none; z-index:30; justify-content:center;
      pointer-events:none;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      color:#fff;
    }
    #toast .pill{
      pointer-events:none;
      background:rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.18);
      padding:10px 14px; border-radius:999px;
      backdrop-filter: blur(10px);
      font-size:14px;
      box-shadow:0 20px 60px rgba(0,0,0,.55);
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="pill" id="statusPill">Hold to charge ðŸŒˆ</div>
    <div class="pill" id="dangerPill">DANGER</div>
  </div>

  <div id="hint">
    <div class="card">
      <div class="title">PsyHold</div>
      <div class="sub">
        Press & hold anywhere.<br/>
        <b>No timer.</b> Pure instinct.<br/>
        Release close to <b>10.00s</b> to unlock rarer creatures.<br/>
        Hold too longâ€¦ you die.
      </div>
      <div class="tiny">
        Pro tip: stay <b>steady</b>. Your finger motion fuels the chaos.
      </div>
    </div>
  </div>

  <div id="result">
    <div class="card">
      <div id="creature">ðŸ¦„</div>
      <div id="headline">NICE NERVES.</div>
      <div id="subtitle">Score: 9.63s â€¢ Mythic Unicorn (Ascended)</div>
      <div id="meta"></div>
      <div class="btnrow">
        <button id="shareBtn">Share</button>
        <button id="againBtn" class="secondary">Play again</button>
      </div>
    </div>
  </div>

  <div id="toast"><div class="pill" id="toastText">Copied.</div></div>

<script>
(() => {
  // ========= Telegram helpers =========
  const tg = (window.Telegram && window.Telegram.WebApp) ? window.Telegram.WebApp : null;
  if (tg) { try { tg.ready(); tg.expand(); } catch(e){} }

  function hapticImpact(level) {
    if (!tg?.HapticFeedback) return;
    try { tg.HapticFeedback.impactOccurred(level); } catch(e){}
  }
  function hapticNotif(type) {
    if (!tg?.HapticFeedback) return;
    try { tg.HapticFeedback.notificationOccurred(type); } catch(e){}
  }

  const toast = document.getElementById("toast");
  const toastText = document.getElementById("toastText");
  let toastT = null;
  function showToast(msg){
    toastText.textContent = msg;
    toast.style.display = "flex";
    clearTimeout(toastT);
    toastT = setTimeout(()=> toast.style.display = "none", 1200);
  }

  function shareText(text) {
    const shareUrl =
      "https://t.me/share/url" +
      "?url=" + encodeURIComponent(location.href) +
      "&text=" + encodeURIComponent(text);

    if (tg && typeof tg.openTelegramLink === "function") {
      tg.openTelegramLink(shareUrl);
      return;
    }
    try { window.open(shareUrl, "_blank", "noopener,noreferrer"); return; } catch(_) {}

    if (navigator.clipboard?.writeText) {
      navigator.clipboard.writeText(text).then(()=>showToast("Copied to clipboard")).catch(()=>{});
      return;
    }
    prompt("Copy this:", text);
  }

  // ========= DOM =========
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });

  const hint = document.getElementById('hint');
  const result = document.getElementById('result');

  const statusPill = document.getElementById('statusPill');
  const dangerPill = document.getElementById('dangerPill');

  const creatureEl = document.getElementById('creature');
  const headlineEl = document.getElementById('headline');
  const subtitleEl = document.getElementById('subtitle');
  const metaEl = document.getElementById('meta');

  const shareBtn = document.getElementById('shareBtn');
  const againBtn = document.getElementById('againBtn');

  // ========= Canvas sizing =========
  let W=0,H=0,dpr=1;
  function resize(){
    dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = Math.floor(innerWidth * dpr);
    H = Math.floor(innerHeight * dpr);
    canvas.width = W; canvas.height = H;
    canvas.style.width = innerWidth + "px";
    canvas.style.height = innerHeight + "px";
  }
  addEventListener('resize', resize);
  resize();

  // ========= Game knobs (the "try again" engine) =========
  const MAX_MS = 10_000;              // death
  const CREATURE_START_MS = 8_500;    // creatures appear on release
  const DANGER_MS = 7_000;            // danger feedback begins
  const CLOSE_MS  = 9_300;            // rarity boost
  const LEGEND_MS = 9_700;            // insane boost
  const GHOST_MS  = 9_050;            // show ghost creature hints
  const FLASH_MS  = 9_900;            // near-death flash cue

  const HAPTIC_STAGES = [7000, 8000, 8700, 9200, 9600, 9850];

  // Movement -> chaos coupling (this is the "steady hand" addiction)
  // Higher means shakier hands = more chaos (harder), calm hand = easier.
  const MOVE_WINDOW_MS = 180;         // smoothing window
  const MOVE_GAIN = 1.65;             // movement energy multiplier
  const MOVE_FALLOFF = 0.90;          // smoothing

  // ========= Score formatting =========
  const toHundredths = (ms) => (Math.floor((ms/1000) * 100) / 100).toFixed(2);

  // ========= Local streak & PB (tiny dopamine) =========
  const LS_STREAK = "psyhold_streak_v2";
  const LS_LASTDAY = "psyhold_lastday_v2";
  const LS_PB = "psyhold_pb_v2";

  function dayKey(d=new Date()){
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,'0');
    const da = String(d.getDate()).padStart(2,'0');
    return `${y}-${m}-${da}`;
  }

  function bumpStreakIfFirstShareToday(){
    const s = parseInt(localStorage.getItem(LS_STREAK) || "0", 10);
    const last = localStorage.getItem(LS_LASTDAY) || "";
    const today = dayKey();
    if (last === today) return s;

    const lastDate = last ? new Date(last + "T00:00:00") : null;
    const todayDate = new Date(today + "T00:00:00");
    const diffDays = lastDate ? Math.round((todayDate - lastDate) / (24*3600*1000)) : 999;

    let newStreak = 1;
    if (diffDays === 1) newStreak = Math.max(1, s + 1);

    localStorage.setItem(LS_STREAK, String(newStreak));
    localStorage.setItem(LS_LASTDAY, today);
    return newStreak;
  }

  function updatePB(msHeld){
    const pb = parseFloat(localStorage.getItem(LS_PB) || "0") || 0;
    const score = parseFloat(toHundredths(msHeld));
    if (!pb || score > pb) {
      localStorage.setItem(LS_PB, String(score));
      return score;
    }
    return pb;
  }

  // ========= Creatures =========
  // (Emoji now = zero-asset viral. Later you can swap to PNG/GIF.)
  const CREATURES = [
    { emoji:"ðŸ¦„", name:"Unicorn", rarity:"Mythic" },
    { emoji:"ðŸ‰", name:"Dragon", rarity:"Mythic" },
    { emoji:"ðŸ§š", name:"Fairy", rarity:"Epic" },
    { emoji:"ðŸ‘ï¸", name:"Cosmic Eye", rarity:"Epic" },
    { emoji:"ðŸ¦‹", name:"Lumen Moth", rarity:"Epic" },
    { emoji:"ðŸ", name:"Ouroboros", rarity:"Rare" },
    { emoji:"ðŸ¦", name:"Chimera", rarity:"Rare" },
    { emoji:"ðŸº", name:"Moon Wolf", rarity:"Rare" },
    { emoji:"ðŸ¦Š", name:"Fox Spirit", rarity:"Uncommon" },
    { emoji:"ðŸ™", name:"Void Octo", rarity:"Uncommon" },
    { emoji:"ðŸª¼", name:"Jelly Wisp", rarity:"Uncommon" },
    { emoji:"ðŸ¸", name:"Trick Toad", rarity:"Common" }
  ];

  function evolutionFor(msHeld){
    if (msHeld >= LEGEND_MS) return { label:"Ascended" };
    if (msHeld >= CLOSE_MS)  return { label:"Evolved" };
    return { label:"Awakened" };
  }

  function microTitle(msHeld, died=false){
    if (died) return "TOO FAR.";
    if (msHeld >= 9900) return "TIME BENDER.";
    if (msHeld >= 9700) return "ABSURD CONTROL.";
    if (msHeld >= 9500) return "NERVE OF STEEL.";
    if (msHeld >= 9300) return "EDGE WALKER.";
    if (msHeld >= 9000) return "STEADY HANDS.";
    if (msHeld >= CREATURE_START_MS) return "NICE NERVES.";
    return "NOT ENOUGH.";
  }

  function pickCreature(msHeld){
    const p = Math.max(0, Math.min(1, msHeld / MAX_MS));
    const expo = Math.pow(p, 3.1);

    // Forced high-tier near death
    if (msHeld >= LEGEND_MS && Math.random() < 0.62) {
      const mythics = CREATURES.filter(c => c.rarity === "Mythic");
      return mythics[(Math.random()*mythics.length)|0];
    }
    if (msHeld >= CLOSE_MS && Math.random() < 0.48) {
      const hi = CREATURES.filter(c => c.rarity === "Epic" || c.rarity === "Mythic");
      return hi[(Math.random()*hi.length)|0];
    }

    const buckets = [
      { filter: c => c.rarity === "Common",   w: 1.00 - expo*0.95 },
      { filter: c => c.rarity === "Uncommon", w: 0.55 + expo*0.38 },
      { filter: c => c.rarity === "Rare",     w: 0.15 + expo*0.52 },
      { filter: c => c.rarity === "Epic",     w: 0.05 + expo*0.58 },
      { filter: c => c.rarity === "Mythic",   w: 0.01 + expo*0.45 }
    ];
    const total = buckets.reduce((s,b)=> s + Math.max(0,b.w), 0);
    let r = Math.random() * total;
    let chosen = buckets[0];
    for (const b of buckets) { r -= Math.max(0,b.w); if (r <= 0) { chosen = b; break; } }
    const pool = CREATURES.filter(chosen.filter);
    return pool[(Math.random()*pool.length)|0];
  }

  // ========= Visual engine =========
  const rand = (a,b)=>a+Math.random()*(b-a);
  let seedA = rand(0, 1000), seedB = rand(0, 1000), seedC = rand(0, 1000);
  function newSeeds(){ seedA=rand(0,1000); seedB=rand(0,1000); seedC=rand(0,1000); }
  function clearCanvas(){ ctx.fillStyle="#000"; ctx.fillRect(0,0,W,H); }

  // Movement tracking (for "steady hand")
  let ptrX = 0, ptrY = 0, ptrDown = false;
  let lastMoveT = 0;
  let moveEnergy = 0; // smoothed 0..?
  let moveEnergyPeak = 0;

  function updateMoveEnergy(x, y, now){
    if (!lastMoveT) { lastMoveT = now; ptrX = x; ptrY = y; return; }
    const dt = Math.max(1, now - lastMoveT);
    const dx = x - ptrX;
    const dy = y - ptrY;
    ptrX = x; ptrY = y; lastMoveT = now;

    // pixels per second (normalized)
    const v = Math.sqrt(dx*dx + dy*dy) / dt; // px/ms
    const sample = Math.min(2.5, v * 28);    // clamp
    moveEnergy = moveEnergy * MOVE_FALLOFF + sample * (1 - MOVE_FALLOFF);
    moveEnergyPeak = Math.max(moveEnergyPeak * 0.995, moveEnergy); // slow decay peak
  }

  // Core orb + rings (the "focus magnet")
  function drawCore(msHeld, chaos, driftX, driftY){
    const p = Math.max(0, Math.min(1, msHeld / MAX_MS));
    const expo = Math.pow(p, 2.5);

    const cx = W/2 + driftX;
    const cy = H/2 + driftY;

    const baseR = Math.min(W,H) * 0.06;
    const r = baseR * (1.0 + expo*2.2) * (1.0 + chaos*0.18);
    const pulse = 0.5 + 0.5*Math.sin(msHeld/1000 * (2.2 + expo*6.5));
    const alpha = 0.07 + expo*0.16;

    // glow
    const g = ctx.createRadialGradient(cx, cy, r*0.2, cx, cy, r*1.25);
    g.addColorStop(0, `rgba(255,255,255,${alpha + pulse*0.06})`);
    g.addColorStop(0.35, `rgba(120,255,240,${alpha*0.55})`);
    g.addColorStop(0.7, `rgba(255,0,120,${alpha*0.22})`);
    g.addColorStop(1, `rgba(0,0,0,0)`);
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(cx, cy, r*1.25, 0, Math.PI*2); ctx.fill();

    // hard core
    const g2 = ctx.createRadialGradient(cx, cy, 0, cx, cy, r*0.45);
    g2.addColorStop(0, `rgba(255,255,255,${0.14 + pulse*0.10})`);
    g2.addColorStop(1, `rgba(0,0,0,0)`);
    ctx.fillStyle = g2;
    ctx.beginPath(); ctx.arc(cx, cy, r*0.45, 0, Math.PI*2); ctx.fill();

    // rings (danger "language" without text)
    if (p > 0.65) {
      const rings = 2 + Math.floor(expo*4);
      ctx.lineWidth = Math.max(1, 2*dpr);
      for (let i=0; i<rings; i++){
        const rr = r*(0.8 + i*0.34) * (1 + pulse*0.08);
        ctx.strokeStyle = `rgba(255,255,255,${(0.06 + expo*0.08) * (1 - i*0.12)})`;
        ctx.beginPath();
        ctx.arc(cx, cy, rr, 0, Math.PI*2);
        ctx.stroke();
      }
    }
  }

  // Ghost creature tease (pre-reward)
  function drawGhostCreature(msHeld, driftX, driftY){
    if (msHeld < GHOST_MS) return;

    const p = Math.max(0, Math.min(1, msHeld / MAX_MS));
    const expo = Math.pow(p, 3.0);

    // flicker windows near end
    const t = msHeld / 1000;
    const flicker = Math.max(0, Math.sin(t * (9 + expo*18)));
    const show = (msHeld > 9300) ? (flicker > 0.15) : (flicker > 0.45);
    if (!show) return;

    // Weighted "ghost set" (feels like you almost unlocked it)
    const ghosts = ["ðŸ¦„","ðŸ‰","ðŸ§š","ðŸ‘ï¸","ðŸ¦‹"];
    const glyph = ghosts[(Math.random()*ghosts.length)|0];

    const cx = W/2 + driftX;
    const cy = H/2 + driftY;
    const yOff = Math.sin(t*4.2) * Math.min(H,W) * 0.02;

    ctx.save();
    ctx.globalAlpha = 0.06 + expo*0.18;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = `${Math.floor((Math.min(W,H) / dpr) * (0.16 + expo*0.08))}px system-ui, -apple-system, Segoe UI, Roboto, sans-serif`;
    ctx.fillText(glyph, cx/dpr, (cy/dpr + yOff/dpr));
    ctx.restore();
  }

  // Psychedelic field (with time deformation + instability)
  function renderPsy(msHeld, chaos, driftX, driftY){
    const p = Math.max(0, Math.min(1, msHeld / MAX_MS));
    const expo = Math.pow(p, 2.75);

    // Time deformation: visuals slow down near end (but real time doesn't)
    // -> makes people misjudge and die -> instant retry.
    const timeWarp = 1.0 - Math.max(0, (p - 0.82)) * 0.55; // down to ~0.7
    const t = (msHeld/1000) * timeWarp;

    const sp = 0.35 + expo * 3.25;
    const zoom = 0.92 + expo * 2.25;

    // Instability grows with danger AND finger movement
    const wob = (p > 0.78 ? (p - 0.78) : 0) * (0.12 + chaos*0.08);
    const wobX = Math.sin(t*18) * wob * W;
    const wobY = Math.cos(t*17) * wob * H;

    const cx = W/2 + driftX + wobX;
    const cy = H/2 + driftY + wobY;

    // block size: tighter near end (feels "more intense")
    const block = Math.max(2, Math.floor((7 - expo*4.9) * dpr));

    // slight RGB split (danger)
    const rgbSplit = (p > 0.80) ? ((p - 0.80) * 10 + chaos*0.6) : 0;

    for (let y=0; y<H; y+=block){
      for (let x=0; x<W; x+=block){
        const nx = ((x - cx)/W) * 2 * zoom;
        const ny = ((y - cy)/H) * 2 * zoom;

        const v =
          Math.sin(nx*3 + seedA + t*sp) +
          Math.cos(ny*4 + seedB - t*sp*0.92) +
          Math.sin((nx+ny)*2 + seedC + t*sp*1.18);

        // Colors fight each other near end (tension)
        const bite = (p > 0.88) ? (p - 0.88) * 1.8 : 0;
        const r = 128 + 127*Math.sin(v + t*1.28 + bite*1.1);
        const g = 128 + 127*Math.sin(v + 2.094 + t*1.06 - bite*0.8);
        const b = 128 + 127*Math.sin(v + 4.188 + t*0.86 + bite*0.4);

        ctx.fillStyle = `rgb(${r|0},${g|0},${b|0})`;
        ctx.fillRect(x, y, block, block);
      }
    }

    // vignette
    const vg = ctx.createRadialGradient(W/2,H/2, Math.min(W,H)*0.10, W/2,H/2, Math.min(W,H)*0.80);
    vg.addColorStop(0, "rgba(0,0,0,0)");
    vg.addColorStop(1, `rgba(0,0,0,${0.24 + expo*0.46})`);
    ctx.fillStyle = vg;
    ctx.fillRect(0,0,W,H);

    // danger tint that increases with chaos
    if (p > 0.70) {
      ctx.fillStyle = `rgba(255, 0, 70, ${(p-0.70)*(0.22 + chaos*0.08)})`;
      ctx.fillRect(0,0,W,H);
    }

    // tiny RGB split illusion (cheap)
    if (rgbSplit > 0.001) {
      ctx.globalAlpha = Math.min(0.10, rgbSplit*0.008);
      ctx.drawImage(canvas, Math.floor(rgbSplit), 0);
      ctx.drawImage(canvas, -Math.floor(rgbSplit), 0);
      ctx.globalAlpha = 1;
    }
  }

  function nearDeathFlash(){
    ctx.fillStyle = "rgba(255,255,255,.085)";
    ctx.fillRect(0,0,W,H);
  }

  function deathCollapse(){
    // color dies + crush
    ctx.fillStyle = "rgba(0,0,0,.35)";
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = "rgba(255,0,90,.18)";
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = "rgba(255,255,255,.04)";
    ctx.fillRect(0,0,W,H);
  }

  // ========= Audio (soft heartbeat - optional, starts on interaction) =========
  let audioCtx = null, osc = null, gain = null, audioEnabled = false;
  function ensureAudio(){
    if (audioCtx) return;
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      osc = audioCtx.createOscillator();
      gain = audioCtx.createGain();
      osc.type = "sine";
      osc.frequency.value = 70;
      gain.gain.value = 0.0;
      osc.connect(gain).connect(audioCtx.destination);
      osc.start();
    } catch(e) { audioCtx = null; }
  }
  function setHeartbeat(msHeld){
    if (!audioEnabled || !audioCtx || !osc || !gain) return;
    const p = Math.max(0, Math.min(1, msHeld / MAX_MS));
    const expo = Math.pow(p, 2.3);
    const baseF = 70 + expo * 170;
    osc.frequency.setValueAtTime(baseF, audioCtx.currentTime);
    const vol = (msHeld < DANGER_MS) ? 0.0 : Math.min(0.05, (msHeld - DANGER_MS) / 3500 * 0.05);
    gain.gain.setTargetAtTime(vol, audioCtx.currentTime, 0.03);
  }
  function muteHeartbeat(){
    if (!gain || !audioCtx) return;
    gain.gain.setTargetAtTime(0.0, audioCtx.currentTime, 0.03);
  }

  // ========= Game state =========
  let holding = false, dead = false;
  let holdStart = 0;
  let rafId = null;
  let lastHapticStage = -1;
  let flashed = false;

  let lastResultText = "";
  let lastSafeMs = 0;
  let lastMsHeld = 0;
  let lastCreature = null;

  // drift: the world tries to slip away, you stabilize by staying steady
  let driftX = 0, driftY = 0;
  let driftVX = 0, driftVY = 0;

  function setUIIdle(){
    dangerPill.style.display = "none";
    statusPill.textContent = "Hold to charge ðŸŒˆ";
  }
  function setUIPlaying(){
    hint.style.display = "none";
    result.style.display = "none";
    dangerPill.style.display = "none";
    statusPill.textContent = "Holdâ€¦ stay steady";
  }

  function resetRound({ showHint=false } = {}){
    holding = false; dead = false;
    lastHapticStage = -1; flashed = false;
    lastSafeMs = 0;
    lastResultText = "";
    lastMsHeld = 0;
    lastCreature = null;

    moveEnergy = 0; moveEnergyPeak = 0;
    driftX = 0; driftY = 0; driftVX = 0; driftVY = 0;

    newSeeds();
    clearCanvas();

    hint.style.display = showHint ? "flex" : "none";
    result.style.display = "none";

    setUIIdle();
  }

  function dangerFeedback(msHeld){
    if (msHeld < DANGER_MS) { dangerPill.style.display = "none"; return; }
    dangerPill.style.display = "inline-block";

    let stage = -1;
    for (let i=0; i<HAPTIC_STAGES.length; i++){
      if (msHeld >= HAPTIC_STAGES[i]) stage = i;
    }
    if (stage !== lastHapticStage) {
      lastHapticStage = stage;
      if (stage <= 0) hapticImpact("light");
      else if (stage === 1) hapticImpact("medium");
      else hapticImpact("heavy");
    }
  }

  function renderMeta(labels){
    metaEl.innerHTML = "";
    for (const label of labels) {
      const span = document.createElement("span");
      span.className = "tag";
      span.textContent = label;
      metaEl.appendChild(span);
    }
  }

  function challengeLine(scoreStr, died){
    if (died) return "I died. Can you get closer to 10.00s and survive?";
    const score = parseFloat(scoreStr);
    if (score >= 9.80) return "I dare you to cross 9.90 without dying.";
    if (score >= 9.60) return "Beat 9.70 without dying.";
    if (score >= 9.30) return "Beat 9.50 without dying.";
    return "Get closer to 10.00 without dying.";
  }

  function showResultCard({ died, msHeld, creature, evo }){
    const pb = (!died) ? updatePB(msHeld) : (parseFloat(localStorage.getItem(LS_PB) || "0") || 0);
    const streak = parseInt(localStorage.getItem(LS_STREAK) || "0", 10);

    const safeHund = toHundredths(Math.max(0, Math.min(MAX_MS - 1, lastSafeMs)));
    const scoreStr = toHundredths(msHeld);
    const leftHund = toHundredths(Math.max(0, MAX_MS - msHeld));

    const calm = Math.max(0, 1 - (moveEnergyPeak * MOVE_GAIN) / 3.0);
    const calmLabel = `Steadiness: ${Math.round(calm*100)}%`;

    if (died) {
      creatureEl.textContent = "ðŸ’€";
      headlineEl.textContent = microTitle(msHeld, true);
      subtitleEl.textContent = `You held too long. Death at 10.00s.`;
      renderMeta([
        `ðŸ’€ Death`,
        `Safe: ${safeHund}s`,
        calmLabel,
        pb ? `PB: ${pb.toFixed(2)}s` : null,
        streak ? `Streak: ${streak}d` : null
      ].filter(Boolean));
      lastResultText = `ðŸ’€ PsyHold: I died. Last safe moment ${safeHund}s. ${challengeLine(scoreStr, true)}\nPlay: ${location.href}`;
      hapticNotif("error");
    } else if (msHeld < CREATURE_START_MS) {
      creatureEl.textContent = "âœ¨";
      headlineEl.textContent = microTitle(msHeld, false);
      subtitleEl.textContent = `No creature. Release closer to 10.00s.`;
      renderMeta([
        `âœ¨ Survived`,
        calmLabel,
        pb ? `PB: ${pb.toFixed(2)}s` : null,
        streak ? `Streak: ${streak}d` : null
      ].filter(Boolean));
      lastResultText = `âœ¨ PsyHold: I chickened out. ${challengeLine(scoreStr, false)}\nPlay: ${location.href}`;
      hapticNotif("warning");
    } else {
      creatureEl.textContent = creature.emoji;
      headlineEl.textContent = microTitle(msHeld, false);
      subtitleEl.textContent = `Score: ${scoreStr}s â€¢ ${creature.rarity} ${creature.name} (${evo.label})`;
      renderMeta([
        `âœ¨ Survived`,
        `${creature.rarity}`,
        `${evo.label}`,
        `${leftHund}s from death`,
        calmLabel,
        pb ? `PB: ${pb.toFixed(2)}s` : null,
        streak ? `Streak: ${streak}d` : null
      ].filter(Boolean));
      lastResultText = `${creature.emoji} PsyHold: ${scoreStr}s â€¢ ${creature.rarity} ${creature.name} (${evo.label}). ${challengeLine(scoreStr, false)}\nPlay: ${location.href}`;
      hapticNotif("success");
    }

    result.style.display = "flex";
  }

  function dieNow(msHeld){
    if (dead) return;
    dead = true;
    holding = false;

    statusPill.textContent = "TOO FAR";
    dangerPill.style.display = "none";

    deathCollapse();
    muteHeartbeat();

    showResultCard({ died:true, msHeld, creature:null, evo:null });
  }

  function startHold(now){
    if (result.style.display === "flex") return;

    ensureAudio();
    if (audioCtx && audioCtx.state === "suspended") { audioCtx.resume().catch(()=>{}); }
    audioEnabled = true;

    holding = true;
    dead = false;
    holdStart = now;
    lastHapticStage = -1;
    flashed = false;

    lastSafeMs = 0;
    lastMsHeld = 0;
    lastCreature = null;
    lastResultText = "";

    moveEnergy = 0; moveEnergyPeak = 0;
    driftX = 0; driftY = 0; driftVX = 0; driftVY = 0;

    setUIPlaying();
    if (!rafId) rafId = requestAnimationFrame(loop);
  }

  function releaseHold(now){
    if (!holding) return;
    holding = false;

    const msHeld = now - holdStart;
    lastMsHeld = msHeld;

    muteHeartbeat();

    if (msHeld >= MAX_MS) { dieNow(msHeld); return; }

    let creature = null, evo = null;
    if (msHeld >= CREATURE_START_MS) {
      creature = pickCreature(msHeld);
      evo = evolutionFor(msHeld);
      lastCreature = creature;
    }

    showResultCard({ died:false, msHeld, creature, evo });
  }

  function loop(now){
    if (holding && !dead) {
      const msHeld = now - holdStart;
      lastSafeMs = Math.min(MAX_MS - 1, msHeld);

      // chaos rises with time AND with movement energy
      const p = Math.max(0, Math.min(1, msHeld / MAX_MS));
      const timeDanger = Math.max(0, p - 0.65) / 0.35; // 0..1 after 6.5s-ish
      const chaos = Math.min(1, (timeDanger*0.85 + moveEnergy*0.25) * MOVE_GAIN);

      // drift: world tries to slide away; steadiness reduces chaos and drift
      // (illusion of control)
      const pull = 0.0009 + timeDanger*0.0030;
      driftVX += (rand(-1,1) * (0.05 + chaos*0.35)) * pull * W;
      driftVY += (rand(-1,1) * (0.05 + chaos*0.35)) * pull * H;

      // friction (but near death it becomes slippery)
      const friction = 0.88 - timeDanger*0.20; // 0.68 near end
      driftVX *= friction;
      driftVY *= friction;

      driftX += driftVX;
      driftY += driftVY;

      // clamp drift so it doesn't go insane
      const clamp = Math.min(W,H) * (0.12 + chaos*0.06);
      driftX = Math.max(-clamp, Math.min(clamp, driftX));
      driftY = Math.max(-clamp, Math.min(clamp, driftY));

      if (msHeld >= MAX_MS) {
        dieNow(msHeld);
      } else {
        renderPsy(msHeld, chaos, driftX, driftY);
        drawCore(msHeld, chaos, driftX, driftY);
        drawGhostCreature(msHeld, driftX, driftY);

        // danger cues
        dangerFeedback(msHeld);

        // near-death flash (once)
        if (!flashed && msHeld >= FLASH_MS) {
          flashed = true;
          nearDeathFlash();
          hapticImpact("heavy");
        }

        setHeartbeat(msHeld);
      }
    }

    rafId = requestAnimationFrame(loop);
  }

  // ========= Input =========
  function canvasPoint(e){
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * dpr;
    const y = (e.clientY - rect.top) * dpr;
    return { x, y };
  }

  canvas.addEventListener('pointerdown', (e)=>{
    e.preventDefault();
    ptrDown = true;
    const now = performance.now();
    const p = canvasPoint(e);
    updateMoveEnergy(p.x, p.y, now);
    try { canvas.setPointerCapture(e.pointerId); } catch(_) {}
    startHold(now);
  }, {passive:false});

  canvas.addEventListener('pointermove', (e)=>{
    if (!ptrDown) return;
    const now = performance.now();
    const p = canvasPoint(e);
    updateMoveEnergy(p.x, p.y, now);
  }, {passive:false});

  canvas.addEventListener('pointerup', (e)=>{
    e.preventDefault();
    ptrDown = false;
    releaseHold(performance.now());
  }, {passive:false});

  canvas.addEventListener('pointercancel', ()=>{
    ptrDown = false;
    releaseHold(performance.now());
  });

  // ========= Buttons =========
  againBtn.addEventListener('click', ()=>{
    result.style.display = "none";
    resetRound();
  });

  shareBtn.addEventListener('click', ()=>{
    const newStreak = bumpStreakIfFirstShareToday();
    const pb = parseFloat(localStorage.getItem(LS_PB) || "0") || 0;

    // Snacky, Telegram-friendly share line
    // (short text = more clicks)
    let line = lastResultText;
    if (!line) line = `PsyHold: no timer. 10.00s = death. Beat me.\nPlay: ${location.href}`;

    let extra = "";
    if (newStreak) extra += ` â€¢ ${newStreak}d streak`;
    if (pb) extra += ` â€¢ PB ${pb.toFixed(2)}s`;
    shareText(line + extra);
  });

  // Tap outside result closes (instant retry loop)
  result.addEventListener("click", (e)=>{
    if (e.target === result) {
      result.style.display = "none";
      resetRound();
    }
  });

  // ========= Boot =========
  resetRound({ showHint:true });
})();
</script>
</body>
</html>
